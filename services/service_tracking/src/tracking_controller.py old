import logging
import signal
import threading
from datetime import datetime, timezone
from typing import Any, Dict, List, Optional

from shared_libs.common.google_storage import GCSPaths, get_storage
from shared_libs.config.all_config import detection_config
from shared_libs.utils.id_generator import create_simple_uuid
from schemas.tracking import TrackingParams
from unverified_track_generator_pipeline import TrackGeneratorPipeline

logger = logging.getLogger(__name__)


class TrackingController:
    """
    Orchestrates the end-to-end unverified track generation process.
    Handles video discovery, pipeline execution, and status reporting.
    """

    def __init__(
        self,
        tenant_id: str,
        tracking_params: TrackingParams,
        custom_name: str = "track_generation_run",
        task_id: Optional[str] = None,
        verbose: bool = True,
    ):
        self.tenant_id = tenant_id
        self.tracking_params = tracking_params
        self.custom_name = custom_name
        self.task_id = task_id
        self.verbose = verbose

        self.storage_client = get_storage(tenant_id)
        self.path_manager = GCSPaths()
        
        self.cancellation_event = threading.Event()
        self._setup_signal_handlers()

        # Initialize Firestore client
        self.firestore_client = None
        if self.task_id:
            try:
                from google.cloud import firestore
                self.firestore_client = firestore.Client()
                logger.info(f"Initialized Firestore client for task_id: {self.task_id}")
            except ImportError:
                logger.warning("google-cloud-firestore not available, status updates disabled")
            except Exception as e:
                logger.error(f"Failed to initialize Firestore client: {e}")

    def _setup_signal_handlers(self):
        """Set up signal handlers for graceful cancellation."""
        def signal_handler(signum, frame):
            logger.info(f"Received signal {signum}, initiating graceful shutdown...")
            self.cancellation_event.set()
            
            if self.task_id:
                self._update_firestore_status("cancelled", f"Cancelled by signal {signum}")
            
            # Stop any active pipelines
            try:
                from shared_libs.common.pipeline import stop_pipeline
                stop_pipeline(self.custom_name)
            except Exception as e:
                logger.error(f"Failed to stop pipeline: {e}")

        signal.signal(signal.SIGTERM, signal_handler)
        signal.signal(signal.SIGINT, signal_handler)

    def discover_videos(self) -> List[str]:
        """Find all available raw videos for the tenant."""
        try:
            raw_videos_path = self.path_manager.get_path("raw_data")
            logger.info(f"Looking for videos in GCS path: {raw_videos_path}")

            blobs = self.storage_client.list_blobs(prefix=raw_videos_path)
            video_extensions = ['.mp4', '.avi', '.mov', '.mkv', '.webm']
            available_videos = [
                b for b in blobs
                if any(b.lower().endswith(ext) for ext in video_extensions)
            ]
            
            logger.info(f"Found {len(available_videos)} videos")

            # Apply limit if specified
            limit = self.tracking_params.video_limit
            if limit and limit > 0:
                available_videos = available_videos[:limit]
                logger.info(f"Limited to {limit} videos")

            return available_videos

        except Exception as e:
            logger.error(f"Error discovering videos: {e}")
            raise

    def _update_firestore_status(self, status: str, error: Optional[str] = None) -> None:
        """Update the Firestore document with the final status."""
        if not self.firestore_client or not self.task_id:
            return

        try:
            doc_ref = self.firestore_client.collection("tracking_progress").document(self.task_id)
            update_data = {
                "status": status,
                "updated_at": datetime.now(timezone.utc).isoformat() + "Z"
            }
            if error:
                update_data["error"] = error
            
            doc_ref.set(update_data, merge=True)
            logger.info(f"Updated Firestore status: {status}")
        except Exception as e:
            logger.error(f"Failed to update Firestore status: {e}")

    def _update_firestore_progress(self, videos_processed: int, total_videos: int) -> None:
        """Update the Firestore document with progress."""
        if not self.firestore_client or not self.task_id:
            return

        try:
            doc_ref = self.firestore_client.collection("tracking_progress").document(self.task_id)
            update_data = {
                "videos_processed": videos_processed,
                "total_videos": total_videos,
                "updated_at": datetime.now(timezone.utc).isoformat() + "Z"
            }
            if not self.cancellation_event.is_set():
                update_data["status"] = "running"
                
            doc_ref.set(update_data, merge=True)
        except Exception as e:
            logger.error(f"Failed to update Firestore progress: {e}")

    def run(self) -> Dict[str, Any]:
        """Execute the tracking process."""
        logger.info(f"Starting Tracking Controller for tenant: {self.tenant_id}")
        
        if self.cancellation_event.is_set():
            return {"status": "cancelled", "message": "Cancelled before start"}

        try:
            videos = self.discover_videos()
            if not videos:
                self._update_firestore_status("completed")
                return {"status": "completed", "message": "No videos found"}

            results = []
            successful_runs = 0
            total_runs = len(videos)

            for i, video_path in enumerate(videos):
                if self.cancellation_event.is_set():
                    break

                try:
                    logger.info(f"Processing video {i+1}/{total_runs}: {video_path}")
                    
                    # Initialize pipeline with new params
                    pipeline = TrackGeneratorPipeline(
                        tracking_params=self.tracking_params,
                        tenant_id=self.tenant_id,
                        verbose=self.verbose,
                        task_id=self.task_id
                    )

                    video_result = pipeline.run(
                        video_path=video_path,
                        resume_from_checkpoint=self.tracking_params.resume_from_checkpoint
                    )

                    results.append({"video_path": video_path, "result": video_result})
                    
                    if video_result.get("status") == "completed":
                        successful_runs += 1
                    
                    self._update_firestore_progress(i + 1, total_runs)

                except Exception as e:
                    logger.error(f"Error processing video {video_path}: {e}")
                    results.append({
                        "video_path": video_path, 
                        "result": {"status": "error", "error": str(e)}
                    })

            # Determine final status
            if self.cancellation_event.is_set():
                status = "cancelled"
                message = "Cancelled during execution"
            elif successful_runs == total_runs:
                status = "completed"
                message = "All videos processed successfully"
            elif successful_runs > 0:
                status = "completed" # Partial success is still completed
                message = f"Processed {successful_runs}/{total_runs} videos"
            else:
                status = "error"
                message = "All videos failed"

            self._update_firestore_status(status, message if status == "error" else None)
            
            return {
                "status": status,
                "message": message,
                "results": results,
                "successful_runs": successful_runs,
                "total_runs": total_runs
            }

        except Exception as e:
            logger.error(f"Tracking run failed: {e}")
            self._update_firestore_status("error", str(e))
            raise
